<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <header>
        <h1>Tricky Parts - Scope | Hoisting | Closures</h1>
    </header>
    <main>
        <section id="5.0">
            <h2>Tricky Parts Intro</h2>
            <img src="./../assets/js_cd_05_trickypart.png" alt="Scope, Hoisting, Closures" />
            <p>First we're going to talk about the concept of Scope, a fundamental topic for any programming language. Then we're going to mention the concepts of hoisting and closures.</p>
            <p>f you sticked to the good programming habits, you would never even encounter the use of hoisting.<br />

                I've still decided to include the so called "tricky concepts" because questions regarding closures and hoisting are often asked in interview questions. I've got you covered! ;)</p>
        </section>
        <section id="5.1">
            <h2>What is scope and why do we need it?</h2>
            <b>What is Scope? Why do we need it? And how can it help us write less error-prone code?</b><br />
            <p>Scope simply allows us to know where we have access to our variables. It shows us the accessability of variables, functions, and objects in some particular part of the code.</p>
            <b>Why would we want to limit the visibility of variables and not have everything availabile everywhere in our code?</b><br />
            <p>Firstly, it provides us with some level of security to our code.<br/>

                Secondly, it helps to improve efficiency, track bugs and reduce them. It also solves the problem of naming variables.
            </p>
            <p>We have three types of scopes:</p>
            <ol>
                <li>Global Scope</li>
                <li>Local Scope / Function Scope</li>
                <li>Block Scope (only with let and const)</li>
            </ol>
            <p>
                Variables defined inside a function are in local scope while variables defined outside of a function are in the global scope. Each function when invoked creates a new scope.<br/>

                There are rules about how scope works, but usually you can search for the closest { and } braces around where you define the variable. That “block” of code is its scope.<br/>

                All of this might be confusing, until you see some examples. You're going to immediately understand what a scope is. Let's explore it in the code.<br/>
            </p>
            <h3>Global Scope</h3>
            <p>When you start writing in a JavaScript document, you're already in the Global scope.</p>
            <pre>
                <code>
                    const name = 'Milos';

                    Variables written inside the Global scope can be accessed by and altered in any other scope.

                    const logName = () => {
                        console.log(name);
                    } 
                    
                    logName();
                </code>
            </pre>
            <i>Advantages of using Global variables</i>
            <ul>
                <li>You can access the global variable from all the functions or modules in a program                </li>
                <li>It is ideally used for storing "constants" as it helps you keep the consistency.</li>
                <li>A Global variable is useful when multiple functions are accessing the same data.</li>
            </ul>
            <i>Disadvantages of using Global Variables</i>
            <ul>
                <li>Too many variables declared as global, then they remain in the memory till program execution is completed. This can cause of Out of Memory issue.</li>
                <li>Data can be modified by any function. Any statement written in the program can change the value of the global variable. This may give unpredictable results in multi-tasking environments.</li>
                <li>If global variables are discontinued due to code refactoring, you will need to change all the modules where they are called.</li>
            </ul>
            <h3>Local Scope</h3>
            <p>Variables defined inside a function are in the local scope.</p>
            <pre>
                <code>
                    // Global Scope

                    const someFunction = () => {
                        // Local Scope #1

                        const anotherFunction = () => {
                            // Local Scope #2
                        }
                    }
                </code>
            </pre>
            <i>Advantages of using Local Variables</i>
            <ul>
                <li>The use of local variables offer a guarantee that the values of variables will remain intact while the task is running</li>
                <li>You can give local variables the same name in different functions because they are only recognized by the function they are declared in.</li>
                <li>Local variables are deleted as soon as any function is over and release the memory space which it occupies.</li>
            </ul>
            <i>Disadvantages of using Local Variables</i>
            <ul>
                <li>They have a very limited scope.</li>
            </ul>
            <h3>Block Scope</h3>
            <p>Block statements like if or for and while loops, unlike functions, don't create a new scope.</p>
            <pre>
                <code>
                    Variables defined inside of a block statement will remain in the scope they were already in.

                    if (true) {
                        // this 'if' conditional block doesn't create a new scope
                        var name = 'Adrian'; // name is still in the global scope
                    }

                    console.log(name); // logs 'Adrian'
                    That is only true with the var. Variables defined with const or let have something called Block scope. That means that they will be available only inside of the block of code you create them in.

                    if (true) {
                        // this 'if' conditional block doesn't create a scope

                        // name is in the global scope because of the 'var' keyword
                        var name = 'Adrian';
                        // likes is in the local scope because of the 'let' keyword
                        let likes = 'Coding';
                        // skills is in the local scope because of the 'const' keyword
                        const skills = 'JavaScript and PHP';
                    }

                    console.log(name); // logs 'Adrian'
                    console.log(likes); // Uncaught ReferenceError: likes is not defined
                    console.log(skills); // Uncaught ReferenceError: skills is not defined
                    If a variable or other expression is not "in the current scope," then it is unavailable for use.
                </code>
            </pre>
            <b>What is more useful?</b><br/>
            <p>The local and global variables are equally important while writing a program in any language. However, a large number of the global variable may occupy a huge memory. An undesirable change to global variables is become tough to identify. Therefore, it is advisable to avoid declaring unwanted global variables. Always declare variables in the scope that you want to use them in.</p>
            <b>KEY DIFFERENCE</b><br />
            <ul>
                <li>Local variable is declared inside a function whereas Global variable is declared outside the function.</li>
                <li>Local variables are created when the function has started execution and is lost when the function terminates, on the other hand, Global variable is created as execution starts and is lost when the program ends.</li>
                <li>Local variable doesn’t provide data sharing whereas Global variable provides data sharing.</li>
                <li>Local variables are stored on the stack whereas the Global variable are stored on a fixed location decided by the compiler.</li>
                <li>Parameters passing is required for local variables whereas it is not necessary for a global variable</li>

            </ul>
            <img src="./../assets/Screenshot 2022-03-30 at 10.09.31.png" />
            <img src="./../assets/Screenshot 2022-03-30 at 10.10.01.png" />
        </section>
        <section>
            <h2>What is hoisting?</h2>
            <p>Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</p>
            <p>This means that no matter where functions and variables are declared, they are moved to the top of their scope regardless of whether their scope is global or local.</p>
            <p>Basically, when Javascript compiles all of your code, all variable declarations using var are hoisted/lifted to the top of their functional (if declared inside a function) or to the top of their global scope (if declared outside of a function) regardless of where the actual declaration has been made. This is what we mean by “hoisting”</p>
            <h3>Variable Hoisting</h3>
            <pre>
                <code>
                    In JavaScript, an undeclared variable is assigned the value undefined at execution and is also of type undefined.

                    console.log(tyepof name); // undefined
                    In JavaScript, a ReferenceError is thrown when trying to access a previously undeclared variable.

                    console.log(name); // ReferenceError: name is not defined
                    Key thing to note in regards to hoisting is that the only thing that gets moved to the top is the variable declaration, not the actual value given to the variable.

                    console.log(myString); // undefined
                    var myString = 'test';
                    var myString;
                    console.log(myString); // undefined
                    myString = 'test';
                    Example 1:
                    var hoist;

                    console.log(hoist); // undefined

                    hoist = 'The variable has been hoisted.'
                    Example 2:
                    function hoist() {
                    var message;

                    console.log(message);

                    message='Hoisting is cool!'
                    }

                    hoist(); // undefined
                </code>
            </pre>
            <h3>Only declarations are hoisted</h3>
            <pre>
                <code>
                    JavaScript only hoists declarations, not initialisations. If a variable is declared and initialised after using it, the value will be undefined. For example:

                    console.log(num); // undefined 

                    var num;

                    num = 6;
                    To avoid this pitfall, we would make sure to declare and initialise the variable before we use it:

                    function hoist() {
                    var message = 'Hoisting is cool!'

                    return message;
                    }

                    hoist(); // Hoisting is cool!
                </code>
            </pre>
            <p>The variable declaration, var message whose scope is the function hoist(), is hoisted to the top of the function.

                This section of the course is the only time that you'll see me use the older syntax like function declarations and var keyword. Why is that? It shows you that newer versions of JavaScript are trying to get away from this way of writing code. It's good to know that hoisting exists, but you should never actually use it. Always declare variables exactly where they should be: at the top of the scope they're used in. That way, your code is always going to be predictable, and you don't have to rely on hoisting.</p>
            <pre>
                <code>
                    let and const hoist but you cannot access them before the actual declaration is evaluated at runtime. What does this mean? Let's see it in a simple example:

                    console.log(myVarString); // undefined
                    var myVarString = 'var';

                    console.log(myLetString); // ReferenceError
                    let myLetString = 'let';

                    console.log(myConstString); // ReferenceError
                    const myConstString = 'const';
                    With let and const you get back exactly what you would expect: a reference error. And that's good. That's JavaScripts's way of letting us know that we need to write clean code. You should always declare variables before using them, it's common sense.
                </code>
            </pre>
            <h3>Function Hoisting</h3>
            <pre>
                <code>
                    The same as var variables, the function declarations are hoisted completely to the top.

                    hoisted(); // 'This function has been hoisted.'

                    function hoisted() {
                    console.log('This function has been hoisted.');
                    };
                    Again, would you ever need to do this? No. Always declare the function before you call it.
                </code>
            </pre>
            <h3>Function expressions</h3>
            <pre>
                <code>
                    Another great thing, is that constants and function expressions save us from doing that. Function expressions (the more modern way of writing functions, with const keyword), are not hoisted.

                    functionExpression(); // ReferenceError
                    
                    const functionExpression = () => {
                      console.log('Will this work?');
                    }  
                </code>
            </pre>
            <p>Hoisting, as well as closures, which we're going to mention in the next section, are complex topics. I would say that they are not all that useful in everyday coding. If you sticked to the good programming habits, you would never even encounter hoisting or closures. I've still decided to include the "tricky concepts" because questions regarding closures and hoisting are often asked in interview questions. You're going to see what I mean in a moment.</p>
        </section>
        <section>
            <h2></h2>
        </section>
    </main>
    <footer>

    </footer>
</body>
</html>